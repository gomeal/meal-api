// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: meal/v1/meal.proto

package meal_v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _meal_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on SearchMealsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchMealsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchMealsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchMealsRequestMultiError, or nil if none found.
func (m *SearchMealsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchMealsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetQuery()) > 100 {
		err := SearchMealsRequestValidationError{
			field:  "Query",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetIncludeIngredientIds()) > 10 {
		err := SearchMealsRequestValidationError{
			field:  "IncludeIngredientIds",
			reason: "value must contain no more than 10 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetIncludeIngredientIds() {
		_, _ = idx, item

		if item < 1 {
			err := SearchMealsRequestValidationError{
				field:  fmt.Sprintf("IncludeIngredientIds[%v]", idx),
				reason: "value must be greater than or equal to 1",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetExcludeIngredientIds()) > 10 {
		err := SearchMealsRequestValidationError{
			field:  "ExcludeIngredientIds",
			reason: "value must contain no more than 10 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetExcludeIngredientIds() {
		_, _ = idx, item

		if item < 1 {
			err := SearchMealsRequestValidationError{
				field:  fmt.Sprintf("ExcludeIngredientIds[%v]", idx),
				reason: "value must be greater than or equal to 1",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if val := m.GetPageSize(); val < 1 || val > 100 {
		err := SearchMealsRequestValidationError{
			field:  "PageSize",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPage() < 1 {
		err := SearchMealsRequestValidationError{
			field:  "Page",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.CategoryId != nil {

		if m.GetCategoryId() < 1 {
			err := SearchMealsRequestValidationError{
				field:  "CategoryId",
				reason: "value must be greater than or equal to 1",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.CuisineId != nil {

		if m.GetCuisineId() < 1 {
			err := SearchMealsRequestValidationError{
				field:  "CuisineId",
				reason: "value must be greater than or equal to 1",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.MaxCookingTimeMinutes != nil {

		if val := m.GetMaxCookingTimeMinutes(); val < 1 || val > 600 {
			err := SearchMealsRequestValidationError{
				field:  "MaxCookingTimeMinutes",
				reason: "value must be inside range [1, 600]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return SearchMealsRequestMultiError(errors)
	}

	return nil
}

// SearchMealsRequestMultiError is an error wrapping multiple validation errors
// returned by SearchMealsRequest.ValidateAll() if the designated constraints
// aren't met.
type SearchMealsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchMealsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchMealsRequestMultiError) AllErrors() []error { return m }

// SearchMealsRequestValidationError is the validation error returned by
// SearchMealsRequest.Validate if the designated constraints aren't met.
type SearchMealsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchMealsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchMealsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchMealsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchMealsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchMealsRequestValidationError) ErrorName() string {
	return "SearchMealsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchMealsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchMealsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchMealsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchMealsRequestValidationError{}

// Validate checks the field values on SearchMealsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchMealsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchMealsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchMealsResponseMultiError, or nil if none found.
func (m *SearchMealsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchMealsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMeals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchMealsResponseValidationError{
						field:  fmt.Sprintf("Meals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchMealsResponseValidationError{
						field:  fmt.Sprintf("Meals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchMealsResponseValidationError{
					field:  fmt.Sprintf("Meals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for HasNextPage

	if len(errors) > 0 {
		return SearchMealsResponseMultiError(errors)
	}

	return nil
}

// SearchMealsResponseMultiError is an error wrapping multiple validation
// errors returned by SearchMealsResponse.ValidateAll() if the designated
// constraints aren't met.
type SearchMealsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchMealsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchMealsResponseMultiError) AllErrors() []error { return m }

// SearchMealsResponseValidationError is the validation error returned by
// SearchMealsResponse.Validate if the designated constraints aren't met.
type SearchMealsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchMealsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchMealsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchMealsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchMealsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchMealsResponseValidationError) ErrorName() string {
	return "SearchMealsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SearchMealsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchMealsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchMealsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchMealsResponseValidationError{}

// Validate checks the field values on Meal with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Meal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Meal with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MealMultiError, or nil if none found.
func (m *Meal) ValidateAll() error {
	return m.validate(true)
}

func (m *Meal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ExternalId

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for ImageUrl

	if all {
		switch v := interface{}(m.GetCategory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MealValidationError{
					field:  "Category",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MealValidationError{
					field:  "Category",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCategory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MealValidationError{
				field:  "Category",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCuisine()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MealValidationError{
					field:  "Cuisine",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MealValidationError{
					field:  "Cuisine",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCuisine()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MealValidationError{
				field:  "Cuisine",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetIngredients() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MealValidationError{
						field:  fmt.Sprintf("Ingredients[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MealValidationError{
						field:  fmt.Sprintf("Ingredients[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MealValidationError{
					field:  fmt.Sprintf("Ingredients[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CookingTimeMinutes

	if m.VideoUrl != nil {
		// no validation rules for VideoUrl
	}

	if len(errors) > 0 {
		return MealMultiError(errors)
	}

	return nil
}

// MealMultiError is an error wrapping multiple validation errors returned by
// Meal.ValidateAll() if the designated constraints aren't met.
type MealMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MealMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MealMultiError) AllErrors() []error { return m }

// MealValidationError is the validation error returned by Meal.Validate if the
// designated constraints aren't met.
type MealValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MealValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MealValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MealValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MealValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MealValidationError) ErrorName() string { return "MealValidationError" }

// Error satisfies the builtin error interface
func (e MealValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MealValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MealValidationError{}

// Validate checks the field values on Category with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Category) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Category with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CategoryMultiError, or nil
// if none found.
func (m *Category) ValidateAll() error {
	return m.validate(true)
}

func (m *Category) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if m.Description != nil {
		// no validation rules for Description
	}

	if len(errors) > 0 {
		return CategoryMultiError(errors)
	}

	return nil
}

// CategoryMultiError is an error wrapping multiple validation errors returned
// by Category.ValidateAll() if the designated constraints aren't met.
type CategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryMultiError) AllErrors() []error { return m }

// CategoryValidationError is the validation error returned by
// Category.Validate if the designated constraints aren't met.
type CategoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryValidationError) ErrorName() string { return "CategoryValidationError" }

// Error satisfies the builtin error interface
func (e CategoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryValidationError{}

// Validate checks the field values on Cuisine with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cuisine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cuisine with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CuisineMultiError, or nil if none found.
func (m *Cuisine) ValidateAll() error {
	return m.validate(true)
}

func (m *Cuisine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if m.Description != nil {
		// no validation rules for Description
	}

	if len(errors) > 0 {
		return CuisineMultiError(errors)
	}

	return nil
}

// CuisineMultiError is an error wrapping multiple validation errors returned
// by Cuisine.ValidateAll() if the designated constraints aren't met.
type CuisineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CuisineMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CuisineMultiError) AllErrors() []error { return m }

// CuisineValidationError is the validation error returned by Cuisine.Validate
// if the designated constraints aren't met.
type CuisineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CuisineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CuisineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CuisineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CuisineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CuisineValidationError) ErrorName() string { return "CuisineValidationError" }

// Error satisfies the builtin error interface
func (e CuisineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCuisine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CuisineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CuisineValidationError{}

// Validate checks the field values on MealIngredient with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MealIngredient) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MealIngredient with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MealIngredientMultiError,
// or nil if none found.
func (m *MealIngredient) ValidateAll() error {
	return m.validate(true)
}

func (m *MealIngredient) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IngredientId

	// no validation rules for IngredientName

	// no validation rules for Measure

	// no validation rules for Position

	if len(errors) > 0 {
		return MealIngredientMultiError(errors)
	}

	return nil
}

// MealIngredientMultiError is an error wrapping multiple validation errors
// returned by MealIngredient.ValidateAll() if the designated constraints
// aren't met.
type MealIngredientMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MealIngredientMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MealIngredientMultiError) AllErrors() []error { return m }

// MealIngredientValidationError is the validation error returned by
// MealIngredient.Validate if the designated constraints aren't met.
type MealIngredientValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MealIngredientValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MealIngredientValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MealIngredientValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MealIngredientValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MealIngredientValidationError) ErrorName() string { return "MealIngredientValidationError" }

// Error satisfies the builtin error interface
func (e MealIngredientValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMealIngredient.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MealIngredientValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MealIngredientValidationError{}

// Validate checks the field values on AddToFavoritesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddToFavoritesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddToFavoritesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddToFavoritesRequestMultiError, or nil if none found.
func (m *AddToFavoritesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddToFavoritesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = AddToFavoritesRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMealId() < 1 {
		err := AddToFavoritesRequestValidationError{
			field:  "MealId",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddToFavoritesRequestMultiError(errors)
	}

	return nil
}

func (m *AddToFavoritesRequest) _validateUuid(uuid string) error {
	if matched := _meal_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// AddToFavoritesRequestMultiError is an error wrapping multiple validation
// errors returned by AddToFavoritesRequest.ValidateAll() if the designated
// constraints aren't met.
type AddToFavoritesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddToFavoritesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddToFavoritesRequestMultiError) AllErrors() []error { return m }

// AddToFavoritesRequestValidationError is the validation error returned by
// AddToFavoritesRequest.Validate if the designated constraints aren't met.
type AddToFavoritesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddToFavoritesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddToFavoritesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddToFavoritesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddToFavoritesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddToFavoritesRequestValidationError) ErrorName() string {
	return "AddToFavoritesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddToFavoritesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddToFavoritesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddToFavoritesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddToFavoritesRequestValidationError{}

// Validate checks the field values on AddToFavoritesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddToFavoritesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddToFavoritesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddToFavoritesResponseMultiError, or nil if none found.
func (m *AddToFavoritesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddToFavoritesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FavoriteId

	if len(errors) > 0 {
		return AddToFavoritesResponseMultiError(errors)
	}

	return nil
}

// AddToFavoritesResponseMultiError is an error wrapping multiple validation
// errors returned by AddToFavoritesResponse.ValidateAll() if the designated
// constraints aren't met.
type AddToFavoritesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddToFavoritesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddToFavoritesResponseMultiError) AllErrors() []error { return m }

// AddToFavoritesResponseValidationError is the validation error returned by
// AddToFavoritesResponse.Validate if the designated constraints aren't met.
type AddToFavoritesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddToFavoritesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddToFavoritesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddToFavoritesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddToFavoritesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddToFavoritesResponseValidationError) ErrorName() string {
	return "AddToFavoritesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddToFavoritesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddToFavoritesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddToFavoritesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddToFavoritesResponseValidationError{}

// Validate checks the field values on GetFavoritesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFavoritesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFavoritesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFavoritesRequestMultiError, or nil if none found.
func (m *GetFavoritesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFavoritesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = GetFavoritesRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetPageSize(); val < 1 || val > 100 {
		err := GetFavoritesRequestValidationError{
			field:  "PageSize",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPage() < 1 {
		err := GetFavoritesRequestValidationError{
			field:  "Page",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetFavoritesRequestMultiError(errors)
	}

	return nil
}

func (m *GetFavoritesRequest) _validateUuid(uuid string) error {
	if matched := _meal_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetFavoritesRequestMultiError is an error wrapping multiple validation
// errors returned by GetFavoritesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetFavoritesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFavoritesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFavoritesRequestMultiError) AllErrors() []error { return m }

// GetFavoritesRequestValidationError is the validation error returned by
// GetFavoritesRequest.Validate if the designated constraints aren't met.
type GetFavoritesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFavoritesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFavoritesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFavoritesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFavoritesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFavoritesRequestValidationError) ErrorName() string {
	return "GetFavoritesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFavoritesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFavoritesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFavoritesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFavoritesRequestValidationError{}

// Validate checks the field values on GetFavoritesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFavoritesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFavoritesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFavoritesResponseMultiError, or nil if none found.
func (m *GetFavoritesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFavoritesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFavoriteMeals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetFavoritesResponseValidationError{
						field:  fmt.Sprintf("FavoriteMeals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetFavoritesResponseValidationError{
						field:  fmt.Sprintf("FavoriteMeals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetFavoritesResponseValidationError{
					field:  fmt.Sprintf("FavoriteMeals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalCount

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for HasNextPage

	if len(errors) > 0 {
		return GetFavoritesResponseMultiError(errors)
	}

	return nil
}

// GetFavoritesResponseMultiError is an error wrapping multiple validation
// errors returned by GetFavoritesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetFavoritesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFavoritesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFavoritesResponseMultiError) AllErrors() []error { return m }

// GetFavoritesResponseValidationError is the validation error returned by
// GetFavoritesResponse.Validate if the designated constraints aren't met.
type GetFavoritesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFavoritesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFavoritesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFavoritesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFavoritesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFavoritesResponseValidationError) ErrorName() string {
	return "GetFavoritesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFavoritesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFavoritesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFavoritesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFavoritesResponseValidationError{}

// Validate checks the field values on FavoriteMeal with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FavoriteMeal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FavoriteMeal with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FavoriteMealMultiError, or
// nil if none found.
func (m *FavoriteMeal) ValidateAll() error {
	return m.validate(true)
}

func (m *FavoriteMeal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FavoriteId

	if all {
		switch v := interface{}(m.GetMeal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FavoriteMealValidationError{
					field:  "Meal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FavoriteMealValidationError{
					field:  "Meal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FavoriteMealValidationError{
				field:  "Meal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AddedAt

	if len(errors) > 0 {
		return FavoriteMealMultiError(errors)
	}

	return nil
}

// FavoriteMealMultiError is an error wrapping multiple validation errors
// returned by FavoriteMeal.ValidateAll() if the designated constraints aren't met.
type FavoriteMealMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FavoriteMealMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FavoriteMealMultiError) AllErrors() []error { return m }

// FavoriteMealValidationError is the validation error returned by
// FavoriteMeal.Validate if the designated constraints aren't met.
type FavoriteMealValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FavoriteMealValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FavoriteMealValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FavoriteMealValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FavoriteMealValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FavoriteMealValidationError) ErrorName() string { return "FavoriteMealValidationError" }

// Error satisfies the builtin error interface
func (e FavoriteMealValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFavoriteMeal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FavoriteMealValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FavoriteMealValidationError{}

// Validate checks the field values on GenerateShoppingListRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateShoppingListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateShoppingListRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateShoppingListRequestMultiError, or nil if none found.
func (m *GenerateShoppingListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateShoppingListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetMealIds()); l < 1 || l > 50 {
		err := GenerateShoppingListRequestValidationError{
			field:  "MealIds",
			reason: "value must contain between 1 and 50 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMealIds() {
		_, _ = idx, item

		if item < 1 {
			err := GenerateShoppingListRequestValidationError{
				field:  fmt.Sprintf("MealIds[%v]", idx),
				reason: "value must be greater than or equal to 1",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return GenerateShoppingListRequestMultiError(errors)
	}

	return nil
}

// GenerateShoppingListRequestMultiError is an error wrapping multiple
// validation errors returned by GenerateShoppingListRequest.ValidateAll() if
// the designated constraints aren't met.
type GenerateShoppingListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateShoppingListRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateShoppingListRequestMultiError) AllErrors() []error { return m }

// GenerateShoppingListRequestValidationError is the validation error returned
// by GenerateShoppingListRequest.Validate if the designated constraints
// aren't met.
type GenerateShoppingListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateShoppingListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateShoppingListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateShoppingListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateShoppingListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateShoppingListRequestValidationError) ErrorName() string {
	return "GenerateShoppingListRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateShoppingListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateShoppingListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateShoppingListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateShoppingListRequestValidationError{}

// Validate checks the field values on GenerateShoppingListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateShoppingListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateShoppingListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateShoppingListResponseMultiError, or nil if none found.
func (m *GenerateShoppingListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateShoppingListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GenerateShoppingListResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GenerateShoppingListResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GenerateShoppingListResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalItemsCount

	// no validation rules for MealsCount

	if len(errors) > 0 {
		return GenerateShoppingListResponseMultiError(errors)
	}

	return nil
}

// GenerateShoppingListResponseMultiError is an error wrapping multiple
// validation errors returned by GenerateShoppingListResponse.ValidateAll() if
// the designated constraints aren't met.
type GenerateShoppingListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateShoppingListResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateShoppingListResponseMultiError) AllErrors() []error { return m }

// GenerateShoppingListResponseValidationError is the validation error returned
// by GenerateShoppingListResponse.Validate if the designated constraints
// aren't met.
type GenerateShoppingListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateShoppingListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateShoppingListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateShoppingListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateShoppingListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateShoppingListResponseValidationError) ErrorName() string {
	return "GenerateShoppingListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateShoppingListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateShoppingListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateShoppingListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateShoppingListResponseValidationError{}

// Validate checks the field values on ShoppingListItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ShoppingListItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShoppingListItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ShoppingListItemMultiError, or nil if none found.
func (m *ShoppingListItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ShoppingListItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IngredientId

	// no validation rules for IngredientName

	if len(errors) > 0 {
		return ShoppingListItemMultiError(errors)
	}

	return nil
}

// ShoppingListItemMultiError is an error wrapping multiple validation errors
// returned by ShoppingListItem.ValidateAll() if the designated constraints
// aren't met.
type ShoppingListItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShoppingListItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShoppingListItemMultiError) AllErrors() []error { return m }

// ShoppingListItemValidationError is the validation error returned by
// ShoppingListItem.Validate if the designated constraints aren't met.
type ShoppingListItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShoppingListItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShoppingListItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShoppingListItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShoppingListItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShoppingListItemValidationError) ErrorName() string { return "ShoppingListItemValidationError" }

// Error satisfies the builtin error interface
func (e ShoppingListItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShoppingListItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShoppingListItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShoppingListItemValidationError{}
